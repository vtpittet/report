

% Hence I rely on the hypothesis that the Zone is integrated to an execution framework by hooking asynchronous code submission to the framework and binding that code to the Zone.


% Given the multity of asynchronous frameworks in the Java ecosystem selecting one 


% In conclusion, this small overview of the asynchronous world shows that in Java, one cannot assume

% Threads used as worker in pools are unaware of when they switch tasks and have no vision...
% Therefore, realizing a Zone 

% In Java, unlike dart and javascript there is no unique imposed asynchronous model but lots of frameworks built on top of natives threads.



% Hence, the Zone developed in this project aim to integrate with any approach. The tool must stay consistent regardless of the asynchronous framework. Single threaded, multi threaded, callbacks, events or promises.

% This multiplicity brings a constraint on
% As long as you can 

% As we will see in the next chapter, the Zone need a hook on asynchronous task submission

% In term of integration, the use of thread pools make it impossible to realize a thread-level hook
% The final solution is proposed into two decoupled parts: the integration and the functionalities. The integration, shortly discussed in chapter \label{ch:asyncworld} simply requires that the asynch

% Thus the present model aims for general and composable features, allowing to build specific behaviors.

% \section{Application Needs}

% What the model need to fill following requirements.

% \begin{itemize}
% \item include input and output to the zoned code
% \item generals hooks that allow error handling implementation as well as on-the-fly Zone definition.
% \item resolution of the contextual ambiguity in asynchronous error handling
% \end{itemize}

% Last elements introduce need of uniform behavior between synchronous and asynchronous execution.
% That is the real point of exec context.

\chapter{The Zone}
\label{ch:zone}

The Zone is an execution context associated to a code block. It represents the asynchronous extension of a scope. Like a scope, the Zone can contain other Zones, define key-value bindings and an inner Zone can see and override outer Zone's key-value bindings. Any code executed or asynchronously submitted in a Zone stays and executes in this Zone.

In addition the Zone defines two kinds of code hooks: the around hooks, to modify submitted code to the Zone and the cross hooks to implement behaviors on entering or leaving a Zone.

%Any code executed or asynchronoulsy submitted in a Zone stays in that Zone. This guarantees asynchronous consistency. A Zone can contain another Zone, as a scope encloses inner scopes. The Zone defines key-value bindings, the equivalent of lexically scoped values. Similarily, the Zone can overload 

The cross hook is the specificity of the Zone. It can represent and easily implement behaviors on Zone transitions. Since Zones are stable across asynchronous executions, zone crossing behaviors run uniformly in synchronous and asynchronous contexts.


The primordial purpose of Zones is to answer the lack of context persistency when submitting asynchronous task. Zones allow to store key-value bindings and persist across asynchronous execution. Hence, they make it possible to share information between asynchronous executions. Because the key-value bindings may be shared by concurrent executions, they must stay immutable to avoid race conditions. However, it is still possible to locally add more key-value bindings by creating a new Zone with additional bindings. It is safe since concurrent executions won't be affected by the local context modification. Furthermore, it is still possible in Java to bypass this limitation, modifiying the \emph{content} of immutable references.

The Zone is intended to provide a context across asynchronous executions. It specifies constant values accessible through context (Zone values), task to execute when entering (cross-in hook) or exiting (cross-out hook) a Zone and hooks around synchronous and asynchronous task execution. Those around hooks make it possible to manipulate the tasks that get executed inside the Zone. While they are not essential to the concept of Zone itself, the opportunity to implement them naturally appears in a Zone implementation since it is a Zone requirement (see next section). The Zone can then simply make these hooks accessible on its interface.

\section{Integration}

The hypothesis that any submitted asynchronous code can be hooked permits to safely ignore the Zone integration when discussing its functionalities. The integration will be always possible. This is a great benefit, since it effectively decouples the Zone functional specification from its integration concerns, confronted to the multity of evoluting asynchronous frameworks in Java.

To integrate a Zone in a program, one can see it as a generalization of a Java thread local\footnote{A Java thread local is a field that is unique for each thread}. Note that the concept of thread local is not limited to Java. Indeed, it can be easily implemented using a mapping with threads as keys and thread locals as values.

When using a thread pool, the concept of thread local becomes limited, even erroneous. Thread locals are bound to a specific thread, but the user does not controls how its tasks are bound to the threads. The common pattern to solve this is to wrap submitted code with instructions that update the thread local for the code.
\begin{lstlisting}

ThreadLocal<T> threadLocal = ...
Executor executor = ...

/*
 * Submitted code will update the thread local on execution.
 */
public void submitWithLocal(Runnable code, T local) {
  Runnable newCode = () -> {
    threadLocal.set(local);
    code.run();
  };

  executor.execute(newCode);
}
\end{lstlisting}

The Zone is a generalization of this method. Rather than binding a runnable, any code is accepted, denoted as \emph{task}. A task is executable code, with optionally inputs and outputs. The Zone handles internally the thread local to store itself and simply exports a bind method.
The Zone takes advantage of this binding operation to apply its internal mechaninc and all submission hooks that it defines. Based on this single binding, it provides:
\begin{itemize}
\item Asynchronous persistent context.
\item Modelled execution flow between the Zones.
\item Flexible programmable hooks on Zone transitions and code submission to the Zone.
\item Extension and reusability mechanisms to extend and implement more Zone features.
\end{itemize}


This pattern efficiently decouples the Zone integration from its functionalities. To use it, one only needs to bind each submitted asynchronous task to the Zone. This can be even simpler using a ``Zone-aware executor'', see chapter \label{ch:impl}.

Chapter \label{ch:asyncworld} showed that in Java, one cannot assume a single execution framework. The presented binding solution is not a uniform solution that automagically works in any context. It describes a single operation to execute on every asynchronous submission, which can even be modularized in the execution framework. That is how the Zone gets integrated in programs.


\section{Crossing Principle}

The crossing principle is the original feature of the Zone presented in this document.

\begin{itemize}
\item Tasks bound to Zones produce zoned results.
\item To use a zoned result, one has to extract it in the current Zone, making its content cross Zone boundaries to current Zone and triggering hooks of crossed zones.
\item If results may contain error as well, crossing hooks can implement error handling.
\end{itemize}

\section{Zone on Petri Nets}

PN are very well suited to schematize asynchronous systems. I will use it to propose a theoretical view of the Zone.

\begin{itemize}
\item Zone is represented as a set of places, sets can only intersect by containment, there exist one set that contains all places.
\item PN token is identified as execution flow and dependency flow that the model try to capture.
\item async tasks run \emph{inside} the Zone.
\item Zoned results may be used \emph{multiple} times.
\end{itemize}


\section{Terminology}

Borrowing abstraction from the petri nets, I define the terms:

\begin{itemize}
\item Token, Zoned Token : Input, output, execution flow that crosses the zones
\item Task, Zoned Task : Code to be executed, with possible input and output (resp. zoned code)
\item Token Hooks or crossing hooks : Code defined by zone, triggered when a token crosses the zone boundary.
\end{itemize}

\section{Properties}

Now that the zone define an operation mode matching (a)synchronous uniformity, I propose the set of essential properties.

\begin{itemize}
\item Zone Values : as in zone prototype
\item Around hooks : function from task to task, Union inherited
\item Crossing Hooks : catch crossing tokens
\end{itemize}

\section{Binding requirements}

In order to make the Zone easy and clear to use, it needs a binding procedure specification.

\begin{itemize}
\item general three-phase binding
\item asynchronous binding
\item synchronous binding
\item internal binding
\end{itemize}

\section{Applications} % Independent chapter ?: Answer to motivation.

At this point, you may wonder if the generalization has gone too far. No error handling, no inherited before hooks, ... I show here how to combine the Zone properties to build up expected features.

\begin{itemize}
\item Contextual and asynchronous error Handling
\item Long stack traces or one Zone per task
\item Asynchronous Dependency tracing
\item Simulated inheritance for arbitrary custom properties (like javascript before hook)
\end{itemize}