
\chapter{Zone Model}
\label{ch:zone}

The Zone described in this chapter is a solution to represent and easily implement behaviors on asynchronous transitions. Moreover, it defines a \emph{uniform} execution in both synchronous and asynchronous execution. 

Recall the two points of the asynchronous definition:
\begin{itemize}
\item Asynchronous code is \emph{submitted} to the executor.
\item Execution is \emph{not sequental} to the submission.
\end{itemize}

The first point allows to define a hook on code submission, used to specify the Zone integration. The second is the asynchronous character of the execution, cause of problems discussed in chapter \label{ch:modiv}.

The hypothesis that any submitted asynchronous code can be hooked permits to safely ignore the Zone integration when discussing its functionalities. The integration will be always possible, and simplified if the Zone provides a method to bind submitted code. This is a great benefit, since it effectively decouples the Zone functional specification from its integration concerns, confronted to the multity of evoluting asynchronous frameworks in Java.


% Hence I rely on the hypothesis that the Zone is integrated to an execution framework by hooking asynchronous code submission to the framework and binding that code to the Zone.


% Given the multity of asynchronous frameworks in the Java ecosystem selecting one 


% In conclusion, this small overview of the asynchronous world shows that in Java, one cannot assume

% Threads used as worker in pools are unaware of when they switch tasks and have no vision...
% Therefore, realizing a Zone 

% In Java, unlike dart and javascript there is no unique imposed asynchronous model but lots of frameworks built on top of natives threads.



% Hence, the Zone developed in this project aim to integrate with any approach. The tool must stay consistent regardless of the asynchronous framework. Single threaded, multi threaded, callbacks, events or promises.

% This multiplicity brings a constraint on
% As long as you can 

% As we will see in the next chapter, the Zone need a hook on asynchronous task submission

% In term of integration, the use of thread pools make it impossible to realize a thread-level hook
% The final solution is proposed into two decoupled parts: the integration and the functionalities. The integration, shortly discussed in chapter \label{ch:asyncworld} simply requires that the asynch

% Thus the present model aims for general and composable features, allowing to build specific behaviors.

\section{Terminology}

The Zone brings its own little vocabulary.

\paragraph{The Zone}

Is an execution context associated to a code block. It represents the asynchronous extension of a scope with the following improvements. Any code 

\section{Application Needs}

What the model need to fill following requirements.

\begin{itemize}
\item include input and output to the zoned code
\item generals hooks that allow error handling implementation as well as on-the-fly Zone definition.
\item resolution of the contextual ambiguity in asynchronous error handling
\end{itemize}

Last elements introduce need of uniform behavior between synchronous and asynchronous execution.
That is the real point of exec context.

\section{Crossing Principle}

This approach brings the needed uniformity. Opposed to inherited error handler binding in prototype Zone.

\begin{itemize}
\item Tasks bound to Zones produce zoned results.
\item To use a zoned result, one has to extract it in the current Zone, making its content cross Zone boundaries to current Zone and triggering hooks of crossed zones.
\item If results may contain error as well, crossing hooks can implement error handling.
\end{itemize}

\section{Zone on Petri Nets}

PN are very well suited to schematize asynchronous systems. I will use it to propose a theoretical view of the Zone.

\begin{itemize}
\item Zone is represented as a set of places, sets can only intersect by containment, there exist one set that contains all places.
\item PN token is identified as execution flow and dependency flow that the model try to capture.
\item async tasks run \emph{inside} the Zone.
\item Zoned results may be used \emph{multiple} times.
\end{itemize}

\section{Terminology}

Borrowing abstraction from the petri nets, I define the terms:

\begin{itemize}
\item Token, Zoned Token : Input, output, execution flow that crosses the zones
\item Task, Zoned Task : Code to be executed, with possible input and output (resp. zoned code)
\item Token Hooks or crossing hooks : Code defined by zone, triggered when a token crosses the zone boundary.
\end{itemize}

\section{Properties}

Now that the zone define an operation mode matching (a)synchronous uniformity, I propose the set of essential properties.

\begin{itemize}
\item Zone Values : as in zone prototype
\item Around hooks : function from task to task, Union inherited
\item Crossing Hooks : catch crossing tokens
\end{itemize}

\section{Binding requirements}

In order to make the Zone easy and clear to use, it needs a binding procedure specification.

\begin{itemize}
\item general three-phase binding
\item asynchronous binding
\item synchronous binding
\item internal binding
\end{itemize}

\section{Applications}

At this point, you may wonder if the generalization has gone too far. No error handling, no inherited before hooks, ... I show here how to combine the Zone properties to build up expected features.

\begin{itemize}
\item Contextual and asynchronous error Handling
\item Long stack traces or one Zone per task
\item Asynchronous Dependency tracing
\item Simulated inheritance for arbitrary custom properties (like javascript before hook)
\end{itemize}