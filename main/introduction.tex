
\chapter{Introduction}
\label{ch:intro}

Who never faced the challenge of debugging an asynchronous program ? And even the somewhat simpler task of following its execution and understanding its dependencies is neither easy, as illustrated in chapter \ref{ch:motiv}.

The main reason of this difficulty is that our standard representations assume determinism and do not hold anymore with the non-deterministic brought by asynchronousness.
However, this non-determinism is precisely what we search when using asynchronous constructs:~there is no way to bypass this problematic.

I propose a solution (chapter \ref{ch:zone}) inspired by the \zonejs\ and \zonedrt\ frameworks to implement functionalities that behave \emph{uniformly} in both synchronous and asynchronous contexts. Moreover this solution aims to be applicable to any underlying asynchronous implementation, at least the most common ones, presented in chapter \ref{ch:asyncworld}. Chapter \ref{ch:approaches} shows how, unlike \zonejs\ and \zonedrt, the Zone for Java implements primitive features, allowing to compose almost any other functionality. This way, it steps down central features as error handling or asynchronous execution tracing to a standard Zone plug-in. It also allows great evolutive flexibility to add aspects fulfilling needs discovered later.

Practical experiments (chapter \ref{ch:inpractice}) built on top of the Zone showed how they allow modularization of complex properties, for example tracing each asynchronous transition of the program. On the other hand, integrating the Zone in an execution framework is hard (consider many cases, avoid duplicate binding), but this work must be done once. After that, use the instrumented executor and zones will be bound transparently.

The Zone is an innovative tool in that it addresses the problem of implementing uniform behaviors across context transitions, regardless of the synchronousness. The Zone allows you to think in terms of transitions between asynchronous tasks and simply implement those transitions once, at a single place.









% Initial objectives were very specific and usage targeted. Final implementation pushes those primary features to the level of optional ones that can be implemented using Zone primitives.



% This work presents my analysis and development process to build the final solution. A first pragmatic approach (Zone prototype) allowed me to grab and solve essential integration concerns :~How to represent the Zone and how to bind zoned code to it with minimal effort of the user.

% Then, naively adding properties implementing wished hooks/solution elements allowed me to quickly grasp the interest and power of the Zone, but also to face rough limitations preventing extension and composability of the Zone. As an answer to this, I developed a model (Zone model) that describes the core functions of the Zone which can be used to represent specific features. (Zone implementation)

% This model appears to be an innovative tool that drives you to think about asynchronous programs in a way you did not know before. We will see (Future work) potential extensions and refinements to both the model and the implementation to make the Zone an even more powerful and easy-to-use tool.



% \section{Objectives}

% \begin{itemize}
% \item Propose solution to stated problems
% \item Target the Java runtime environment
% \item Build an usable tool providing asynchronous execution context in a similar fashion to Zones in \zonejs\ and \zonedrt\.
% \item Targeted features include asynchronous error handling, long stack traces and generation of asynchronous sequence diagram.
% \item The tool should be easily usable and require few, if no adaptation in the user code. I will call this the integration concerns.
% \end{itemize}


