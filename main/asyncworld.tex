
\chapter{Asynchronous Approaches}
\label{ch:asyncworld}

% \begin{itemize}
% \item Thread : OS preemption or VM preemption based on locking mechanisms.
% \item Thread pools : popular Java framework to optimize threaded programs.
% \item Callbacks : non-preemptive concurrency. Manual execution unit yield using callbacks (js, dart)
% \item Callbacks with thread pools : scalable event loop (\vertx)
% \item Promises or CompletableFutures (in Java) : late-binding callbacks
% \end{itemize}

This work specifically targets the asynchronous world. Hence, I will start with a little tour of the most common asynchronous execution frameworks. Clearly, this vision is axed toward the Java programming language, but it is adapted for the current work, proposing a Java solution.

There is nothing to be done before a clarification of what I mean by ``asynchronous''. Indeed, as many other buzz-words (see ``reactive'' for example), ``asynchronous'' is used in variety of contexts for different meanings. Often, ``asynchronous'' describes a method call on a dedicated asynchronous API, with potential callback code that gets executed after completion. This is the dominant approach in JavaScript. Here, it describes more generally any code that does not run \emph{in sequence} of the code that submitted it. It may run later if there is only one execution unit (single-threaded). It may run in parallel or later, if there is two or more execution unit (multi-threaded). This can occur upon starting a new thread:

\begin{lstlisting}
(new Thread(() -> {
  // async task's code...
}).start();
\end{lstlisting}

Submitting a runnable to an executor:

\begin{lstlisting}
Executor executor = ...
executor.execute(() -> {
  // async task's code...
});
\end{lstlisting}

Registering a listener or event handler:
\begin{lstlisting}
class Listener implements MouseMotionListener {
  public void mouseMoved(MouseEvent e) {
    // async code
    System.out.println("Moved !");
  }

  public void mouseDragged(MouseEvent e) {
    // async code
    System.out.println("Dragged !");
  }
}

JPanel jPanel = ...

// async code submission
jPanel.addMouseMotionListener(new Listener());
\end{lstlisting}

Or any way, as long as the submitted code does not execute in sequence of its submission.

Let's take a deeper look on the different approaches to execute asynchronous code in Java that I considered before designing the Zone for Java.


\section{Threads}

In nowadays machines, threads are the basic unit of asynchronous execution. They are a very good tool, since they allow automatic time slicing via preemptive scheduling. This make them suitable for operative system, since no executed program has to be aware of interruptions, at the cost of context switching overhead.

The Java language ports this functionality to the programmer through its threads. However, the virtual machine does not allow context switching inside its threads. Actually, the operating system supporting the java threads transparently undertakes this function. Since one Java thread cannot be interrupted to switch the task it is running (i.e. accomplish a context-switch) using Java's native threads is limited to one task per thread. Running a new task means instantiating and garbage collecting a whole thread.

\section{Thread Pools}

The high cost of allocating and collecting a Java thread, is unaffordable to reach high performances. That is why thread pools are very popluar in Java. Considering the asynchronous approach, a thread pool is just an optimisation of the threaded approach. Rather than submitting the code to one thread, one submits it to the thread pool. When a thread is idle, the thread pool assign it a pending task, until no tasks are pending. The most recent Java implementation is the \lstinline{ForkJoinPool}, bringing fine-tuned environnement to execute parallel fork-join tasks.

In fact, there is an analogy between the single thread approach, relying on operating system scheduling and the thread pool. The thread pool acts as a non-preemptive scheduler for the Java virtual machine, and threads are its processes.

Thread pools bring huge speedup, avoiding costly thread instantiation, but loose the preemptive scheduling, with the risk of task starvation.
And final consequence: one-to-one pairing between executed tasks and threads is lost. Threads become blind workers, with no control on the tasks they execute.

\section{Callbacks}

Callbacks 

An asynchronous method with a callback is a way to bind asynchronous . Hence 

The callback approach is less seen in Java, but is central in Dart and javascript. This makes it interesing enough to consider, since \zonejs\ and \zonedrt\ are the starting points of the project. But additionally, the popular \vertx\ framework makes a high use of this pattern on the Java virtual machine. 

They can be built in Java, especially with the lambdas of Java 8. The \vertx\ framework is a good example. But remember this is just an API. Under the hood, \vertx\ uses a thread pool to get asynchronousness.

\section{Promises}
aka completable future in Java.

\section{Handlers}
At the risk of oversimplifying the reality, I regroup in this category framework as Swing, based on observers or handlers
and Akka or \vertx\ (again) who use the concept of actor, respectively verticle. Basically, an actor is an intelligent handler that is desigend to have more control on the message it gets and can in turn send messages to other actors. Regarding the asynchronous behavior, observers and actor do the same. They differ in term of concurrency concurrency control, but this is not the focus of this work.


\section*{}
In conclusion, this small overview of the asynchronous world shows that in Java, one cannot assume

Threads used as worker in pools are unaware of when they switch tasks and have no vision...
Therefore, realizing a Zone 


\section*{Conclusion for the Zone} % move in next chapter.
In Java, unlike dart and javascript there is no unique imposed asynchronous model but lots of frameworks built on top of natives threads.
Hence, the Zone developed in this project aim to integrate with any approach. The tool must stay consistent regardless of the asynchronous framework. Single threaded, multi threaded, callbacks, events or promises.

This multiplicity brings a constraint on
As long as you can 

As we will see in the next chapter, the Zone need a hook on asynchronous task submission

In term of integration, the use of thread pools make it impossible to realize a thread-level hook